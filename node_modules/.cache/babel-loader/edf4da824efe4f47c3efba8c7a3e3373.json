{"ast":null,"code":"import _toConsumableArray from\"/home/sabrina/codes/weather-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";import React from\"react\";import forecastCSS from\"../styles/forecast.module.css\";import{jsx as _jsx}from\"react/jsx-runtime\";import{jsxs as _jsxs}from\"react/jsx-runtime\";import{Fragment as _Fragment}from\"react/jsx-runtime\";function ForecastGraph(_ref){var data=_ref.data,temperature=_ref.temperature,style=_ref.style;// finding the maximum and minimum values in the array\nvar max=Math.max.apply(Math,_toConsumableArray(temperature)),min=Math.min.apply(Math,_toConsumableArray(temperature));// finding the difference to be able to calculate by how much the height of the line should be curved\nvar difference=max-min;// the max height to not go out of boundaries\nvar maxHeight=data.heightOfContainers;var degreeOfChange=maxHeight/difference;// degree of change of Y axis\n// the initial values of the graph\nvar temperatureData={x1:0,y1:0,x2:-data.startingPoint,y2:50};return/*#__PURE__*/_jsx(_Fragment,{children:/*#__PURE__*/_jsx(\"svg\",{className:forecastCSS.graph,id:style,children:temperature.map(function(each,key){temperatureData.x1=temperatureData.x2;temperatureData.y1=temperatureData.y2;temperatureData.x2+=data.widthOfContainers;if(temperature[key-1]>each){temperatureData.y2+=degreeOfChange*Math.abs(temperature[key-1]-each);}else if(temperature[key-1]<each){temperatureData.y2-=degreeOfChange*Math.abs(temperature[key-1]-each);}else{temperatureData.y2+=0;}return/*#__PURE__*/_jsxs(\"g\",{children:[/*#__PURE__*/_jsx(\"circle\",{cx:temperatureData.x2,cy:temperatureData.y2,r:\"4px\",stroke:\"white\",strokeWidth:\"1\",fill:\"black\"}),style===forecastCSS.dayTime&&/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsxs(\"text\",{fontSize:\"16\",fill:\"white\",textAnchor:\"middle\",alignmentBaseline:\"baseline\",x:temperatureData.x2,y:temperatureData.y2-10,children:[temperature[key],\"\\xB0\"]}),/*#__PURE__*/_jsx(\"line\",{x1:temperatureData.x1,y1:temperatureData.y1,x2:temperatureData.x2,y2:temperatureData.y2,stroke:\"white\"})]}),style===forecastCSS.nightTime&&/*#__PURE__*/_jsxs(_Fragment,{children:[/*#__PURE__*/_jsx(\"line\",{x1:temperatureData.x1,y1:temperatureData.y1,x2:temperatureData.x2,y2:temperatureData.y2,stroke:\"white\"}),/*#__PURE__*/_jsxs(\"text\",{fontSize:\"16\",fill:\"white\",textAnchor:\"middle\",alignmentBaseline:\"baseline\",x:temperatureData.x2,y:temperatureData.y2+20,children:[temperature[key],\"\\xB0\"]})]})]},key);})})});}export default ForecastGraph;","map":{"version":3,"sources":["/home/sabrina/codes/weather-app/src/components/ForecastGraph.js"],"names":["React","forecastCSS","ForecastGraph","data","temperature","style","max","Math","min","difference","maxHeight","heightOfContainers","degreeOfChange","temperatureData","x1","y1","x2","startingPoint","y2","graph","map","each","key","widthOfContainers","abs","dayTime","nightTime"],"mappings":"6HAAA,MAAOA,CAAAA,KAAP,KAAkB,OAAlB,CACA,MAAOC,CAAAA,WAAP,KAAwB,+BAAxB,C,6IAEA,QAASC,CAAAA,aAAT,MAAqD,IAA5BC,CAAAA,IAA4B,MAA5BA,IAA4B,CAAtBC,WAAsB,MAAtBA,WAAsB,CAATC,KAAS,MAATA,KAAS,CACnD;AAEA,GAAIC,CAAAA,GAAG,CAAGC,IAAI,CAACD,GAAL,OAAAC,IAAI,oBAAQH,WAAR,EAAd,CACEI,GAAG,CAAGD,IAAI,CAACC,GAAL,OAAAD,IAAI,oBAAQH,WAAR,EADZ,CAEA;AACA,GAAIK,CAAAA,UAAU,CAAGH,GAAG,CAAGE,GAAvB,CACA;AACA,GAAIE,CAAAA,SAAS,CAAGP,IAAI,CAACQ,kBAArB,CACA,GAAIC,CAAAA,cAAc,CAAGF,SAAS,CAAGD,UAAjC,CAA6C;AAE7C;AACA,GAAMI,CAAAA,eAAe,CAAG,CACtBC,EAAE,CAAE,CADkB,CAEtBC,EAAE,CAAE,CAFkB,CAGtBC,EAAE,CAAE,CAACb,IAAI,CAACc,aAHY,CAItBC,EAAE,CAAE,EAJkB,CAAxB,CAOA,mBACE,sCACE,YAAK,SAAS,CAAEjB,WAAW,CAACkB,KAA5B,CAAmC,EAAE,CAAEd,KAAvC,UACGD,WAAW,CAACgB,GAAZ,CAAgB,SAACC,IAAD,CAAOC,GAAP,CAAe,CAC9BT,eAAe,CAACC,EAAhB,CAAqBD,eAAe,CAACG,EAArC,CACAH,eAAe,CAACE,EAAhB,CAAqBF,eAAe,CAACK,EAArC,CACAL,eAAe,CAACG,EAAhB,EAAsBb,IAAI,CAACoB,iBAA3B,CAEA,GAAInB,WAAW,CAACkB,GAAG,CAAG,CAAP,CAAX,CAAuBD,IAA3B,CAAiC,CAC/BR,eAAe,CAACK,EAAhB,EACEN,cAAc,CAAGL,IAAI,CAACiB,GAAL,CAASpB,WAAW,CAACkB,GAAG,CAAG,CAAP,CAAX,CAAuBD,IAAhC,CADnB,CAED,CAHD,IAGO,IAAIjB,WAAW,CAACkB,GAAG,CAAG,CAAP,CAAX,CAAuBD,IAA3B,CAAiC,CACtCR,eAAe,CAACK,EAAhB,EACEN,cAAc,CAAGL,IAAI,CAACiB,GAAL,CAASpB,WAAW,CAACkB,GAAG,CAAG,CAAP,CAAX,CAAuBD,IAAhC,CADnB,CAED,CAHM,IAGA,CACLR,eAAe,CAACK,EAAhB,EAAsB,CAAtB,CACD,CAED,mBACE,kCACE,eACE,EAAE,CAAEL,eAAe,CAACG,EADtB,CAEE,EAAE,CAAEH,eAAe,CAACK,EAFtB,CAGE,CAAC,CAAC,KAHJ,CAIE,MAAM,CAAC,OAJT,CAKE,WAAW,CAAC,GALd,CAME,IAAI,CAAC,OANP,EADF,CAWGb,KAAK,GAAKJ,WAAW,CAACwB,OAAtB,eACC,wCACE,cACE,QAAQ,CAAC,IADX,CAEE,IAAI,CAAC,OAFP,CAGE,UAAU,CAAC,QAHb,CAIE,iBAAiB,CAAC,UAJpB,CAKE,CAAC,CAAEZ,eAAe,CAACG,EALrB,CAME,CAAC,CAAEH,eAAe,CAACK,EAAhB,CAAqB,EAN1B,WAQGd,WAAW,CAACkB,GAAD,CARd,UADF,cAWE,aACE,EAAE,CAAET,eAAe,CAACC,EADtB,CAEE,EAAE,CAAED,eAAe,CAACE,EAFtB,CAGE,EAAE,CAAEF,eAAe,CAACG,EAHtB,CAIE,EAAE,CAAEH,eAAe,CAACK,EAJtB,CAKE,MAAM,CAAC,OALT,EAXF,GAZJ,CAiCGb,KAAK,GAAKJ,WAAW,CAACyB,SAAtB,eACC,wCACE,aACE,EAAE,CAAEb,eAAe,CAACC,EADtB,CAEE,EAAE,CAAED,eAAe,CAACE,EAFtB,CAGE,EAAE,CAAEF,eAAe,CAACG,EAHtB,CAIE,EAAE,CAAEH,eAAe,CAACK,EAJtB,CAKE,MAAM,CAAC,OALT,EADF,cAQE,cACE,QAAQ,CAAC,IADX,CAEE,IAAI,CAAC,OAFP,CAGE,UAAU,CAAC,QAHb,CAIE,iBAAiB,CAAC,UAJpB,CAKE,CAAC,CAAEL,eAAe,CAACG,EALrB,CAME,CAAC,CAAEH,eAAe,CAACK,EAAhB,CAAqB,EAN1B,WAQGd,WAAW,CAACkB,GAAD,CARd,UARF,GAlCJ,GAAQA,GAAR,CADF,CAyDD,CAxEA,CADH,EADF,EADF,CA+ED,CAED,cAAepB,CAAAA,aAAf","sourcesContent":["import React from \"react\";\nimport forecastCSS from \"../styles/forecast.module.css\";\n\nfunction ForecastGraph({ data, temperature, style }) {\n  // finding the maximum and minimum values in the array\n\n  let max = Math.max(...temperature),\n    min = Math.min(...temperature);\n  // finding the difference to be able to calculate by how much the height of the line should be curved\n  let difference = max - min;\n  // the max height to not go out of boundaries\n  let maxHeight = data.heightOfContainers;\n  let degreeOfChange = maxHeight / difference; // degree of change of Y axis\n\n  // the initial values of the graph\n  const temperatureData = {\n    x1: 0,\n    y1: 0,\n    x2: -data.startingPoint,\n    y2: 50,\n  };\n\n  return (\n    <>\n      <svg className={forecastCSS.graph} id={style}>\n        {temperature.map((each, key) => {\n          temperatureData.x1 = temperatureData.x2;\n          temperatureData.y1 = temperatureData.y2;\n          temperatureData.x2 += data.widthOfContainers;\n\n          if (temperature[key - 1] > each) {\n            temperatureData.y2 +=\n              degreeOfChange * Math.abs(temperature[key - 1] - each);\n          } else if (temperature[key - 1] < each) {\n            temperatureData.y2 -=\n              degreeOfChange * Math.abs(temperature[key - 1] - each);\n          } else {\n            temperatureData.y2 += 0;\n          }\n\n          return (\n            <g key={key}>\n              <circle\n                cx={temperatureData.x2}\n                cy={temperatureData.y2}\n                r=\"4px\"\n                stroke=\"white\"\n                strokeWidth=\"1\"\n                fill=\"black\"\n              />\n\n              {/* display the data according to dayTime standards */}\n              {style === forecastCSS.dayTime && (\n                <>\n                  <text\n                    fontSize=\"16\"\n                    fill=\"white\"\n                    textAnchor=\"middle\"\n                    alignmentBaseline=\"baseline\"\n                    x={temperatureData.x2}\n                    y={temperatureData.y2 - 10}\n                  >\n                    {temperature[key]}°\n                  </text>\n                  <line\n                    x1={temperatureData.x1}\n                    y1={temperatureData.y1}\n                    x2={temperatureData.x2}\n                    y2={temperatureData.y2}\n                    stroke=\"white\"\n                  />\n                </>\n              )}\n              {/* display the data according to nightTime standards */}\n              {style === forecastCSS.nightTime && (\n                <>\n                  <line\n                    x1={temperatureData.x1}\n                    y1={temperatureData.y1}\n                    x2={temperatureData.x2}\n                    y2={temperatureData.y2}\n                    stroke=\"white\"\n                  />\n                  <text\n                    fontSize=\"16\"\n                    fill=\"white\"\n                    textAnchor=\"middle\"\n                    alignmentBaseline=\"baseline\"\n                    x={temperatureData.x2}\n                    y={temperatureData.y2 + 20}\n                  >\n                    {temperature[key]}°\n                  </text>\n                </>\n              )}\n            </g>\n          );\n        })}\n      </svg>\n    </>\n  );\n}\n\nexport default ForecastGraph;\n"]},"metadata":{},"sourceType":"module"}